/*
 * Stacks Blockchain API
 * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a> 
 *
 * The version of the OpenAPI document: v3.0.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package so.hiro.stacks_blockchain_api_client.api;

import so.hiro.stacks_blockchain_api_client.ApiCallback;
import so.hiro.stacks_blockchain_api_client.ApiClient;
import so.hiro.stacks_blockchain_api_client.ApiException;
import so.hiro.stacks_blockchain_api_client.ApiResponse;
import so.hiro.stacks_blockchain_api_client.Configuration;
import so.hiro.stacks_blockchain_api_client.Pair;
import so.hiro.stacks_blockchain_api_client.ProgressRequestBody;
import so.hiro.stacks_blockchain_api_client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import so.hiro.stacks_blockchain_api_client.model.NonFungibleTokenHistoryEventList;
import so.hiro.stacks_blockchain_api_client.model.NonFungibleTokenHoldingsList;
import so.hiro.stacks_blockchain_api_client.model.NonFungibleTokenMetadata;
import so.hiro.stacks_blockchain_api_client.model.NonFungibleTokenMintList;
import so.hiro.stacks_blockchain_api_client.model.NonFungibleTokensMetadataList;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class NonFungibleTokensApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public NonFungibleTokensApi() {
        this(Configuration.getDefaultApiClient());
    }

    public NonFungibleTokensApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for getContractNftMetadata
     * @param contractId token&#39;s contract id (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Non fungible tokens metadata for contract id </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getContractNftMetadataCall(String contractId, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/extended/v1/tokens/{contractId}/nft/metadata"
            .replaceAll("\\{" + "contractId" + "\\}", localVarApiClient.escapeString(contractId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getContractNftMetadataValidateBeforeCall(String contractId, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'contractId' is set
        if (contractId == null) {
            throw new ApiException("Missing the required parameter 'contractId' when calling getContractNftMetadata(Async)");
        }
        

        okhttp3.Call localVarCall = getContractNftMetadataCall(contractId, _callback);
        return localVarCall;

    }

    /**
     * Non fungible tokens metadata for contract id
     * Retrieves metadata for non fungible tokens for a given contract id. More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts).
     * @param contractId token&#39;s contract id (required)
     * @return NonFungibleTokenMetadata
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Non fungible tokens metadata for contract id </td><td>  -  </td></tr>
     </table>
     */
    public NonFungibleTokenMetadata getContractNftMetadata(String contractId) throws ApiException {
        ApiResponse<NonFungibleTokenMetadata> localVarResp = getContractNftMetadataWithHttpInfo(contractId);
        return localVarResp.getData();
    }

    /**
     * Non fungible tokens metadata for contract id
     * Retrieves metadata for non fungible tokens for a given contract id. More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts).
     * @param contractId token&#39;s contract id (required)
     * @return ApiResponse&lt;NonFungibleTokenMetadata&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Non fungible tokens metadata for contract id </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<NonFungibleTokenMetadata> getContractNftMetadataWithHttpInfo(String contractId) throws ApiException {
        okhttp3.Call localVarCall = getContractNftMetadataValidateBeforeCall(contractId, null);
        Type localVarReturnType = new TypeToken<NonFungibleTokenMetadata>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Non fungible tokens metadata for contract id (asynchronously)
     * Retrieves metadata for non fungible tokens for a given contract id. More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts).
     * @param contractId token&#39;s contract id (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Non fungible tokens metadata for contract id </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getContractNftMetadataAsync(String contractId, final ApiCallback<NonFungibleTokenMetadata> _callback) throws ApiException {

        okhttp3.Call localVarCall = getContractNftMetadataValidateBeforeCall(contractId, _callback);
        Type localVarReturnType = new TypeToken<NonFungibleTokenMetadata>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getNftHistory
     * @param assetIdentifier token asset class identifier (required)
     * @param value hex representation of the token&#39;s unique value (required)
     * @param limit max number of events to fetch (optional, default to 50)
     * @param offset index of first event to fetch (optional, default to 0)
     * @param unanchored whether or not to include events from unconfirmed transactions (optional, default to false)
     * @param txMetadata whether or not to include the complete transaction metadata instead of just &#x60;tx_id&#x60;. Enabling this option can affect performance and response times. (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Non-Fungible Token event history </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNftHistoryCall(String assetIdentifier, String value, Integer limit, Integer offset, Boolean unanchored, Boolean txMetadata, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/extended/v1/tokens/nft/history";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (assetIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("asset_identifier", assetIdentifier));
        }

        if (value != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("value", value));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (unanchored != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("unanchored", unanchored));
        }

        if (txMetadata != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tx_metadata", txMetadata));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getNftHistoryValidateBeforeCall(String assetIdentifier, String value, Integer limit, Integer offset, Boolean unanchored, Boolean txMetadata, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'assetIdentifier' is set
        if (assetIdentifier == null) {
            throw new ApiException("Missing the required parameter 'assetIdentifier' when calling getNftHistory(Async)");
        }
        
        // verify the required parameter 'value' is set
        if (value == null) {
            throw new ApiException("Missing the required parameter 'value' when calling getNftHistory(Async)");
        }
        

        okhttp3.Call localVarCall = getNftHistoryCall(assetIdentifier, value, limit, offset, unanchored, txMetadata, _callback);
        return localVarCall;

    }

    /**
     * Non-Fungible Token history
     * Retrieves all events relevant to a Non-Fungible Token. Useful to determine the ownership history of a particular asset.  More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts). 
     * @param assetIdentifier token asset class identifier (required)
     * @param value hex representation of the token&#39;s unique value (required)
     * @param limit max number of events to fetch (optional, default to 50)
     * @param offset index of first event to fetch (optional, default to 0)
     * @param unanchored whether or not to include events from unconfirmed transactions (optional, default to false)
     * @param txMetadata whether or not to include the complete transaction metadata instead of just &#x60;tx_id&#x60;. Enabling this option can affect performance and response times. (optional, default to false)
     * @return NonFungibleTokenHistoryEventList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Non-Fungible Token event history </td><td>  -  </td></tr>
     </table>
     */
    public NonFungibleTokenHistoryEventList getNftHistory(String assetIdentifier, String value, Integer limit, Integer offset, Boolean unanchored, Boolean txMetadata) throws ApiException {
        ApiResponse<NonFungibleTokenHistoryEventList> localVarResp = getNftHistoryWithHttpInfo(assetIdentifier, value, limit, offset, unanchored, txMetadata);
        return localVarResp.getData();
    }

    /**
     * Non-Fungible Token history
     * Retrieves all events relevant to a Non-Fungible Token. Useful to determine the ownership history of a particular asset.  More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts). 
     * @param assetIdentifier token asset class identifier (required)
     * @param value hex representation of the token&#39;s unique value (required)
     * @param limit max number of events to fetch (optional, default to 50)
     * @param offset index of first event to fetch (optional, default to 0)
     * @param unanchored whether or not to include events from unconfirmed transactions (optional, default to false)
     * @param txMetadata whether or not to include the complete transaction metadata instead of just &#x60;tx_id&#x60;. Enabling this option can affect performance and response times. (optional, default to false)
     * @return ApiResponse&lt;NonFungibleTokenHistoryEventList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Non-Fungible Token event history </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<NonFungibleTokenHistoryEventList> getNftHistoryWithHttpInfo(String assetIdentifier, String value, Integer limit, Integer offset, Boolean unanchored, Boolean txMetadata) throws ApiException {
        okhttp3.Call localVarCall = getNftHistoryValidateBeforeCall(assetIdentifier, value, limit, offset, unanchored, txMetadata, null);
        Type localVarReturnType = new TypeToken<NonFungibleTokenHistoryEventList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Non-Fungible Token history (asynchronously)
     * Retrieves all events relevant to a Non-Fungible Token. Useful to determine the ownership history of a particular asset.  More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts). 
     * @param assetIdentifier token asset class identifier (required)
     * @param value hex representation of the token&#39;s unique value (required)
     * @param limit max number of events to fetch (optional, default to 50)
     * @param offset index of first event to fetch (optional, default to 0)
     * @param unanchored whether or not to include events from unconfirmed transactions (optional, default to false)
     * @param txMetadata whether or not to include the complete transaction metadata instead of just &#x60;tx_id&#x60;. Enabling this option can affect performance and response times. (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Non-Fungible Token event history </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNftHistoryAsync(String assetIdentifier, String value, Integer limit, Integer offset, Boolean unanchored, Boolean txMetadata, final ApiCallback<NonFungibleTokenHistoryEventList> _callback) throws ApiException {

        okhttp3.Call localVarCall = getNftHistoryValidateBeforeCall(assetIdentifier, value, limit, offset, unanchored, txMetadata, _callback);
        Type localVarReturnType = new TypeToken<NonFungibleTokenHistoryEventList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getNftHoldings
     * @param principal token owner&#39;s STX address or Smart Contract ID (required)
     * @param assetIdentifiers identifiers of the token asset classes to filter for (optional)
     * @param limit max number of tokens to fetch (optional, default to 50)
     * @param offset index of first tokens to fetch (optional, default to 0)
     * @param unanchored whether or not to include tokens from unconfirmed transactions (optional, default to false)
     * @param txMetadata whether or not to include the complete transaction metadata instead of just &#x60;tx_id&#x60;. Enabling this option can affect performance and response times. (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of Non-Fungible Token holdings </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNftHoldingsCall(String principal, List<String> assetIdentifiers, Integer limit, Integer offset, Boolean unanchored, Boolean txMetadata, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/extended/v1/tokens/nft/holdings";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (principal != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("principal", principal));
        }

        if (assetIdentifiers != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "asset_identifiers", assetIdentifiers));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (unanchored != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("unanchored", unanchored));
        }

        if (txMetadata != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tx_metadata", txMetadata));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getNftHoldingsValidateBeforeCall(String principal, List<String> assetIdentifiers, Integer limit, Integer offset, Boolean unanchored, Boolean txMetadata, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'principal' is set
        if (principal == null) {
            throw new ApiException("Missing the required parameter 'principal' when calling getNftHoldings(Async)");
        }
        

        okhttp3.Call localVarCall = getNftHoldingsCall(principal, assetIdentifiers, limit, offset, unanchored, txMetadata, _callback);
        return localVarCall;

    }

    /**
     * Non-Fungible Token holdings
     * Retrieves the list of Non-Fungible Tokens owned by the given principal (STX address or Smart Contract ID). Results can be filtered by one or more asset identifiers and can include metadata about the transaction that made the principal own each token.  More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts). 
     * @param principal token owner&#39;s STX address or Smart Contract ID (required)
     * @param assetIdentifiers identifiers of the token asset classes to filter for (optional)
     * @param limit max number of tokens to fetch (optional, default to 50)
     * @param offset index of first tokens to fetch (optional, default to 0)
     * @param unanchored whether or not to include tokens from unconfirmed transactions (optional, default to false)
     * @param txMetadata whether or not to include the complete transaction metadata instead of just &#x60;tx_id&#x60;. Enabling this option can affect performance and response times. (optional, default to false)
     * @return NonFungibleTokenHoldingsList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of Non-Fungible Token holdings </td><td>  -  </td></tr>
     </table>
     */
    public NonFungibleTokenHoldingsList getNftHoldings(String principal, List<String> assetIdentifiers, Integer limit, Integer offset, Boolean unanchored, Boolean txMetadata) throws ApiException {
        ApiResponse<NonFungibleTokenHoldingsList> localVarResp = getNftHoldingsWithHttpInfo(principal, assetIdentifiers, limit, offset, unanchored, txMetadata);
        return localVarResp.getData();
    }

    /**
     * Non-Fungible Token holdings
     * Retrieves the list of Non-Fungible Tokens owned by the given principal (STX address or Smart Contract ID). Results can be filtered by one or more asset identifiers and can include metadata about the transaction that made the principal own each token.  More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts). 
     * @param principal token owner&#39;s STX address or Smart Contract ID (required)
     * @param assetIdentifiers identifiers of the token asset classes to filter for (optional)
     * @param limit max number of tokens to fetch (optional, default to 50)
     * @param offset index of first tokens to fetch (optional, default to 0)
     * @param unanchored whether or not to include tokens from unconfirmed transactions (optional, default to false)
     * @param txMetadata whether or not to include the complete transaction metadata instead of just &#x60;tx_id&#x60;. Enabling this option can affect performance and response times. (optional, default to false)
     * @return ApiResponse&lt;NonFungibleTokenHoldingsList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of Non-Fungible Token holdings </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<NonFungibleTokenHoldingsList> getNftHoldingsWithHttpInfo(String principal, List<String> assetIdentifiers, Integer limit, Integer offset, Boolean unanchored, Boolean txMetadata) throws ApiException {
        okhttp3.Call localVarCall = getNftHoldingsValidateBeforeCall(principal, assetIdentifiers, limit, offset, unanchored, txMetadata, null);
        Type localVarReturnType = new TypeToken<NonFungibleTokenHoldingsList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Non-Fungible Token holdings (asynchronously)
     * Retrieves the list of Non-Fungible Tokens owned by the given principal (STX address or Smart Contract ID). Results can be filtered by one or more asset identifiers and can include metadata about the transaction that made the principal own each token.  More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts). 
     * @param principal token owner&#39;s STX address or Smart Contract ID (required)
     * @param assetIdentifiers identifiers of the token asset classes to filter for (optional)
     * @param limit max number of tokens to fetch (optional, default to 50)
     * @param offset index of first tokens to fetch (optional, default to 0)
     * @param unanchored whether or not to include tokens from unconfirmed transactions (optional, default to false)
     * @param txMetadata whether or not to include the complete transaction metadata instead of just &#x60;tx_id&#x60;. Enabling this option can affect performance and response times. (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of Non-Fungible Token holdings </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNftHoldingsAsync(String principal, List<String> assetIdentifiers, Integer limit, Integer offset, Boolean unanchored, Boolean txMetadata, final ApiCallback<NonFungibleTokenHoldingsList> _callback) throws ApiException {

        okhttp3.Call localVarCall = getNftHoldingsValidateBeforeCall(principal, assetIdentifiers, limit, offset, unanchored, txMetadata, _callback);
        Type localVarReturnType = new TypeToken<NonFungibleTokenHoldingsList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getNftMetadataList
     * @param limit max number of tokens to fetch (optional)
     * @param offset index of first tokens to fetch (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of non fungible tokens metadata </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNftMetadataListCall(Integer limit, Integer offset, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/extended/v1/tokens/nft/metadata";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getNftMetadataListValidateBeforeCall(Integer limit, Integer offset, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = getNftMetadataListCall(limit, offset, _callback);
        return localVarCall;

    }

    /**
     * Non fungible tokens metadata list
     * Retrieves a list of non fungible tokens with their metadata. More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts).
     * @param limit max number of tokens to fetch (optional)
     * @param offset index of first tokens to fetch (optional)
     * @return NonFungibleTokensMetadataList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of non fungible tokens metadata </td><td>  -  </td></tr>
     </table>
     */
    public NonFungibleTokensMetadataList getNftMetadataList(Integer limit, Integer offset) throws ApiException {
        ApiResponse<NonFungibleTokensMetadataList> localVarResp = getNftMetadataListWithHttpInfo(limit, offset);
        return localVarResp.getData();
    }

    /**
     * Non fungible tokens metadata list
     * Retrieves a list of non fungible tokens with their metadata. More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts).
     * @param limit max number of tokens to fetch (optional)
     * @param offset index of first tokens to fetch (optional)
     * @return ApiResponse&lt;NonFungibleTokensMetadataList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of non fungible tokens metadata </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<NonFungibleTokensMetadataList> getNftMetadataListWithHttpInfo(Integer limit, Integer offset) throws ApiException {
        okhttp3.Call localVarCall = getNftMetadataListValidateBeforeCall(limit, offset, null);
        Type localVarReturnType = new TypeToken<NonFungibleTokensMetadataList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Non fungible tokens metadata list (asynchronously)
     * Retrieves a list of non fungible tokens with their metadata. More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts).
     * @param limit max number of tokens to fetch (optional)
     * @param offset index of first tokens to fetch (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of non fungible tokens metadata </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNftMetadataListAsync(Integer limit, Integer offset, final ApiCallback<NonFungibleTokensMetadataList> _callback) throws ApiException {

        okhttp3.Call localVarCall = getNftMetadataListValidateBeforeCall(limit, offset, _callback);
        Type localVarReturnType = new TypeToken<NonFungibleTokensMetadataList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getNftMints
     * @param assetIdentifier token asset class identifier (required)
     * @param limit max number of events to fetch (optional, default to 50)
     * @param offset index of first event to fetch (optional, default to 0)
     * @param unanchored whether or not to include events from unconfirmed transactions (optional, default to false)
     * @param txMetadata whether or not to include the complete transaction metadata instead of just &#x60;tx_id&#x60;. Enabling this option can affect performance and response times. (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Non-Fungible Token mints </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNftMintsCall(String assetIdentifier, Integer limit, Integer offset, Boolean unanchored, Boolean txMetadata, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/extended/v1/tokens/nft/mints";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (assetIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("asset_identifier", assetIdentifier));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (unanchored != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("unanchored", unanchored));
        }

        if (txMetadata != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tx_metadata", txMetadata));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getNftMintsValidateBeforeCall(String assetIdentifier, Integer limit, Integer offset, Boolean unanchored, Boolean txMetadata, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'assetIdentifier' is set
        if (assetIdentifier == null) {
            throw new ApiException("Missing the required parameter 'assetIdentifier' when calling getNftMints(Async)");
        }
        

        okhttp3.Call localVarCall = getNftMintsCall(assetIdentifier, limit, offset, unanchored, txMetadata, _callback);
        return localVarCall;

    }

    /**
     * Non-Fungible Token mints
     * Retrieves all mint events for a Non-Fungible Token asset class. Useful to determine which NFTs of a particular collection have been claimed.  More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts). 
     * @param assetIdentifier token asset class identifier (required)
     * @param limit max number of events to fetch (optional, default to 50)
     * @param offset index of first event to fetch (optional, default to 0)
     * @param unanchored whether or not to include events from unconfirmed transactions (optional, default to false)
     * @param txMetadata whether or not to include the complete transaction metadata instead of just &#x60;tx_id&#x60;. Enabling this option can affect performance and response times. (optional, default to false)
     * @return NonFungibleTokenMintList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Non-Fungible Token mints </td><td>  -  </td></tr>
     </table>
     */
    public NonFungibleTokenMintList getNftMints(String assetIdentifier, Integer limit, Integer offset, Boolean unanchored, Boolean txMetadata) throws ApiException {
        ApiResponse<NonFungibleTokenMintList> localVarResp = getNftMintsWithHttpInfo(assetIdentifier, limit, offset, unanchored, txMetadata);
        return localVarResp.getData();
    }

    /**
     * Non-Fungible Token mints
     * Retrieves all mint events for a Non-Fungible Token asset class. Useful to determine which NFTs of a particular collection have been claimed.  More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts). 
     * @param assetIdentifier token asset class identifier (required)
     * @param limit max number of events to fetch (optional, default to 50)
     * @param offset index of first event to fetch (optional, default to 0)
     * @param unanchored whether or not to include events from unconfirmed transactions (optional, default to false)
     * @param txMetadata whether or not to include the complete transaction metadata instead of just &#x60;tx_id&#x60;. Enabling this option can affect performance and response times. (optional, default to false)
     * @return ApiResponse&lt;NonFungibleTokenMintList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Non-Fungible Token mints </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<NonFungibleTokenMintList> getNftMintsWithHttpInfo(String assetIdentifier, Integer limit, Integer offset, Boolean unanchored, Boolean txMetadata) throws ApiException {
        okhttp3.Call localVarCall = getNftMintsValidateBeforeCall(assetIdentifier, limit, offset, unanchored, txMetadata, null);
        Type localVarReturnType = new TypeToken<NonFungibleTokenMintList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Non-Fungible Token mints (asynchronously)
     * Retrieves all mint events for a Non-Fungible Token asset class. Useful to determine which NFTs of a particular collection have been claimed.  More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts). 
     * @param assetIdentifier token asset class identifier (required)
     * @param limit max number of events to fetch (optional, default to 50)
     * @param offset index of first event to fetch (optional, default to 0)
     * @param unanchored whether or not to include events from unconfirmed transactions (optional, default to false)
     * @param txMetadata whether or not to include the complete transaction metadata instead of just &#x60;tx_id&#x60;. Enabling this option can affect performance and response times. (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Non-Fungible Token mints </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNftMintsAsync(String assetIdentifier, Integer limit, Integer offset, Boolean unanchored, Boolean txMetadata, final ApiCallback<NonFungibleTokenMintList> _callback) throws ApiException {

        okhttp3.Call localVarCall = getNftMintsValidateBeforeCall(assetIdentifier, limit, offset, unanchored, txMetadata, _callback);
        Type localVarReturnType = new TypeToken<NonFungibleTokenMintList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
