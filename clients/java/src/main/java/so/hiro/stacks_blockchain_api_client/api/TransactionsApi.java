/*
 * Stacks Blockchain API
 * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a> 
 *
 * The version of the OpenAPI document: v3.0.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package so.hiro.stacks_blockchain_api_client.api;

import so.hiro.stacks_blockchain_api_client.ApiCallback;
import so.hiro.stacks_blockchain_api_client.ApiClient;
import so.hiro.stacks_blockchain_api_client.ApiException;
import so.hiro.stacks_blockchain_api_client.ApiResponse;
import so.hiro.stacks_blockchain_api_client.Configuration;
import so.hiro.stacks_blockchain_api_client.Pair;
import so.hiro.stacks_blockchain_api_client.ProgressRequestBody;
import so.hiro.stacks_blockchain_api_client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import so.hiro.stacks_blockchain_api_client.model.AnyOfobjectobject;
import so.hiro.stacks_blockchain_api_client.model.AnyOfobjectobjectobjectobjectobject;
import java.io.File;
import so.hiro.stacks_blockchain_api_client.model.GetRawTransactionResult;
import so.hiro.stacks_blockchain_api_client.model.MempoolTransactionListResponse;
import so.hiro.stacks_blockchain_api_client.model.PostCoreNodeTransactionsError;
import so.hiro.stacks_blockchain_api_client.model.TransactionResults;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class TransactionsApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public TransactionsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public TransactionsApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for getAddressMempoolTransactions
     * @param address Transactions for the address (required)
     * @param limit max number of transactions to fetch (optional)
     * @param offset index of first transaction to fetch (optional)
     * @param unanchored Include transaction data from unanchored (i.e. unconfirmed) microblocks (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of Transactions </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAddressMempoolTransactionsCall(String address, Integer limit, Integer offset, Boolean unanchored, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/extended/v1/address/{address}/mempool"
            .replaceAll("\\{" + "address" + "\\}", localVarApiClient.escapeString(address.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (unanchored != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("unanchored", unanchored));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getAddressMempoolTransactionsValidateBeforeCall(String address, Integer limit, Integer offset, Boolean unanchored, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'address' is set
        if (address == null) {
            throw new ApiException("Missing the required parameter 'address' when calling getAddressMempoolTransactions(Async)");
        }
        

        okhttp3.Call localVarCall = getAddressMempoolTransactionsCall(address, limit, offset, unanchored, _callback);
        return localVarCall;

    }

    /**
     * Transactions for address
     * Retrieves all transactions for a given address that are currently in mempool
     * @param address Transactions for the address (required)
     * @param limit max number of transactions to fetch (optional)
     * @param offset index of first transaction to fetch (optional)
     * @param unanchored Include transaction data from unanchored (i.e. unconfirmed) microblocks (optional, default to false)
     * @return Object
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of Transactions </td><td>  -  </td></tr>
     </table>
     */
    public Object getAddressMempoolTransactions(String address, Integer limit, Integer offset, Boolean unanchored) throws ApiException {
        ApiResponse<Object> localVarResp = getAddressMempoolTransactionsWithHttpInfo(address, limit, offset, unanchored);
        return localVarResp.getData();
    }

    /**
     * Transactions for address
     * Retrieves all transactions for a given address that are currently in mempool
     * @param address Transactions for the address (required)
     * @param limit max number of transactions to fetch (optional)
     * @param offset index of first transaction to fetch (optional)
     * @param unanchored Include transaction data from unanchored (i.e. unconfirmed) microblocks (optional, default to false)
     * @return ApiResponse&lt;Object&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of Transactions </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Object> getAddressMempoolTransactionsWithHttpInfo(String address, Integer limit, Integer offset, Boolean unanchored) throws ApiException {
        okhttp3.Call localVarCall = getAddressMempoolTransactionsValidateBeforeCall(address, limit, offset, unanchored, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Transactions for address (asynchronously)
     * Retrieves all transactions for a given address that are currently in mempool
     * @param address Transactions for the address (required)
     * @param limit max number of transactions to fetch (optional)
     * @param offset index of first transaction to fetch (optional)
     * @param unanchored Include transaction data from unanchored (i.e. unconfirmed) microblocks (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of Transactions </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAddressMempoolTransactionsAsync(String address, Integer limit, Integer offset, Boolean unanchored, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = getAddressMempoolTransactionsValidateBeforeCall(address, limit, offset, unanchored, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getDroppedMempoolTransactionList
     * @param limit max number of mempool transactions to fetch (optional, default to 96)
     * @param offset index of first mempool transaction to fetch (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of dropped mempool transactions </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getDroppedMempoolTransactionListCall(Integer limit, Integer offset, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/extended/v1/tx/mempool/dropped";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getDroppedMempoolTransactionListValidateBeforeCall(Integer limit, Integer offset, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = getDroppedMempoolTransactionListCall(limit, offset, _callback);
        return localVarCall;

    }

    /**
     * Get dropped mempool transactions
     * Retrieves all recently-broadcast transactions that have been dropped from the mempool.  Transactions are dropped from the mempool if:  * they were stale and awaiting garbage collection or,  * were expensive,  or  * were replaced with a new fee 
     * @param limit max number of mempool transactions to fetch (optional, default to 96)
     * @param offset index of first mempool transaction to fetch (optional)
     * @return Object
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of dropped mempool transactions </td><td>  -  </td></tr>
     </table>
     */
    public Object getDroppedMempoolTransactionList(Integer limit, Integer offset) throws ApiException {
        ApiResponse<Object> localVarResp = getDroppedMempoolTransactionListWithHttpInfo(limit, offset);
        return localVarResp.getData();
    }

    /**
     * Get dropped mempool transactions
     * Retrieves all recently-broadcast transactions that have been dropped from the mempool.  Transactions are dropped from the mempool if:  * they were stale and awaiting garbage collection or,  * were expensive,  or  * were replaced with a new fee 
     * @param limit max number of mempool transactions to fetch (optional, default to 96)
     * @param offset index of first mempool transaction to fetch (optional)
     * @return ApiResponse&lt;Object&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of dropped mempool transactions </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Object> getDroppedMempoolTransactionListWithHttpInfo(Integer limit, Integer offset) throws ApiException {
        okhttp3.Call localVarCall = getDroppedMempoolTransactionListValidateBeforeCall(limit, offset, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get dropped mempool transactions (asynchronously)
     * Retrieves all recently-broadcast transactions that have been dropped from the mempool.  Transactions are dropped from the mempool if:  * they were stale and awaiting garbage collection or,  * were expensive,  or  * were replaced with a new fee 
     * @param limit max number of mempool transactions to fetch (optional, default to 96)
     * @param offset index of first mempool transaction to fetch (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of dropped mempool transactions </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getDroppedMempoolTransactionListAsync(Integer limit, Integer offset, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = getDroppedMempoolTransactionListValidateBeforeCall(limit, offset, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getMempoolTransactionList
     * @param senderAddress Filter to only return transactions with this sender address. (optional)
     * @param recipientAddress Filter to only return transactions with this recipient address (only applicable for STX transfer tx types). (optional)
     * @param address Filter to only return transactions with this address as the sender or recipient (recipient only applicable for STX transfer tx types). (optional)
     * @param limit max number of mempool transactions to fetch (optional, default to 96)
     * @param offset index of first mempool transaction to fetch (optional)
     * @param unanchored Include transaction data from unanchored (i.e. unconfirmed) microblocks (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of mempool transactions </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMempoolTransactionListCall(String senderAddress, String recipientAddress, String address, Integer limit, Integer offset, Boolean unanchored, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/extended/v1/tx/mempool";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (senderAddress != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sender_address", senderAddress));
        }

        if (recipientAddress != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recipient_address", recipientAddress));
        }

        if (address != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("address", address));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (unanchored != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("unanchored", unanchored));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMempoolTransactionListValidateBeforeCall(String senderAddress, String recipientAddress, String address, Integer limit, Integer offset, Boolean unanchored, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = getMempoolTransactionListCall(senderAddress, recipientAddress, address, limit, offset, unanchored, _callback);
        return localVarCall;

    }

    /**
     * Get mempool transactions
     * Retrieves all transactions that have been recently broadcast to the mempool. These are pending transactions awaiting confirmation.  If you need to monitor new transactions, we highly recommend subscribing to [WebSockets or Socket.io](https://github.com/hirosystems/stacks-blockchain-api/tree/master/client) for real-time updates. 
     * @param senderAddress Filter to only return transactions with this sender address. (optional)
     * @param recipientAddress Filter to only return transactions with this recipient address (only applicable for STX transfer tx types). (optional)
     * @param address Filter to only return transactions with this address as the sender or recipient (recipient only applicable for STX transfer tx types). (optional)
     * @param limit max number of mempool transactions to fetch (optional, default to 96)
     * @param offset index of first mempool transaction to fetch (optional)
     * @param unanchored Include transaction data from unanchored (i.e. unconfirmed) microblocks (optional, default to false)
     * @return MempoolTransactionListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of mempool transactions </td><td>  -  </td></tr>
     </table>
     */
    public MempoolTransactionListResponse getMempoolTransactionList(String senderAddress, String recipientAddress, String address, Integer limit, Integer offset, Boolean unanchored) throws ApiException {
        ApiResponse<MempoolTransactionListResponse> localVarResp = getMempoolTransactionListWithHttpInfo(senderAddress, recipientAddress, address, limit, offset, unanchored);
        return localVarResp.getData();
    }

    /**
     * Get mempool transactions
     * Retrieves all transactions that have been recently broadcast to the mempool. These are pending transactions awaiting confirmation.  If you need to monitor new transactions, we highly recommend subscribing to [WebSockets or Socket.io](https://github.com/hirosystems/stacks-blockchain-api/tree/master/client) for real-time updates. 
     * @param senderAddress Filter to only return transactions with this sender address. (optional)
     * @param recipientAddress Filter to only return transactions with this recipient address (only applicable for STX transfer tx types). (optional)
     * @param address Filter to only return transactions with this address as the sender or recipient (recipient only applicable for STX transfer tx types). (optional)
     * @param limit max number of mempool transactions to fetch (optional, default to 96)
     * @param offset index of first mempool transaction to fetch (optional)
     * @param unanchored Include transaction data from unanchored (i.e. unconfirmed) microblocks (optional, default to false)
     * @return ApiResponse&lt;MempoolTransactionListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of mempool transactions </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<MempoolTransactionListResponse> getMempoolTransactionListWithHttpInfo(String senderAddress, String recipientAddress, String address, Integer limit, Integer offset, Boolean unanchored) throws ApiException {
        okhttp3.Call localVarCall = getMempoolTransactionListValidateBeforeCall(senderAddress, recipientAddress, address, limit, offset, unanchored, null);
        Type localVarReturnType = new TypeToken<MempoolTransactionListResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get mempool transactions (asynchronously)
     * Retrieves all transactions that have been recently broadcast to the mempool. These are pending transactions awaiting confirmation.  If you need to monitor new transactions, we highly recommend subscribing to [WebSockets or Socket.io](https://github.com/hirosystems/stacks-blockchain-api/tree/master/client) for real-time updates. 
     * @param senderAddress Filter to only return transactions with this sender address. (optional)
     * @param recipientAddress Filter to only return transactions with this recipient address (only applicable for STX transfer tx types). (optional)
     * @param address Filter to only return transactions with this address as the sender or recipient (recipient only applicable for STX transfer tx types). (optional)
     * @param limit max number of mempool transactions to fetch (optional, default to 96)
     * @param offset index of first mempool transaction to fetch (optional)
     * @param unanchored Include transaction data from unanchored (i.e. unconfirmed) microblocks (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of mempool transactions </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMempoolTransactionListAsync(String senderAddress, String recipientAddress, String address, Integer limit, Integer offset, Boolean unanchored, final ApiCallback<MempoolTransactionListResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMempoolTransactionListValidateBeforeCall(senderAddress, recipientAddress, address, limit, offset, unanchored, _callback);
        Type localVarReturnType = new TypeToken<MempoolTransactionListResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getRawTransactionById
     * @param txId Hash of transaction (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Hex encoded serialized transaction </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot find transaction for given ID </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRawTransactionByIdCall(String txId, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/extended/v1/tx/{tx_id}/raw"
            .replaceAll("\\{" + "tx_id" + "\\}", localVarApiClient.escapeString(txId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRawTransactionByIdValidateBeforeCall(String txId, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'txId' is set
        if (txId == null) {
            throw new ApiException("Missing the required parameter 'txId' when calling getRawTransactionById(Async)");
        }
        

        okhttp3.Call localVarCall = getRawTransactionByIdCall(txId, _callback);
        return localVarCall;

    }

    /**
     * Get Raw Transaction
     * Retrieves a hex encoded serialized transaction for a given ID 
     * @param txId Hash of transaction (required)
     * @return GetRawTransactionResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Hex encoded serialized transaction </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot find transaction for given ID </td><td>  -  </td></tr>
     </table>
     */
    public GetRawTransactionResult getRawTransactionById(String txId) throws ApiException {
        ApiResponse<GetRawTransactionResult> localVarResp = getRawTransactionByIdWithHttpInfo(txId);
        return localVarResp.getData();
    }

    /**
     * Get Raw Transaction
     * Retrieves a hex encoded serialized transaction for a given ID 
     * @param txId Hash of transaction (required)
     * @return ApiResponse&lt;GetRawTransactionResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Hex encoded serialized transaction </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot find transaction for given ID </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetRawTransactionResult> getRawTransactionByIdWithHttpInfo(String txId) throws ApiException {
        okhttp3.Call localVarCall = getRawTransactionByIdValidateBeforeCall(txId, null);
        Type localVarReturnType = new TypeToken<GetRawTransactionResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Raw Transaction (asynchronously)
     * Retrieves a hex encoded serialized transaction for a given ID 
     * @param txId Hash of transaction (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Hex encoded serialized transaction </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot find transaction for given ID </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRawTransactionByIdAsync(String txId, final ApiCallback<GetRawTransactionResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRawTransactionByIdValidateBeforeCall(txId, _callback);
        Type localVarReturnType = new TypeToken<GetRawTransactionResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getTransactionById
     * @param txId Hash of transaction (required)
     * @param eventOffset The number of events to skip (optional, default to 0)
     * @param eventLimit The numbers of events to return (optional, default to 96)
     * @param unanchored Include transaction data from unanchored (i.e. unconfirmed) microblocks (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Transaction </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot find transaction for given ID </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getTransactionByIdCall(String txId, Integer eventOffset, Integer eventLimit, Boolean unanchored, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/extended/v1/tx/{tx_id}"
            .replaceAll("\\{" + "tx_id" + "\\}", localVarApiClient.escapeString(txId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (eventOffset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("event_offset", eventOffset));
        }

        if (eventLimit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("event_limit", eventLimit));
        }

        if (unanchored != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("unanchored", unanchored));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getTransactionByIdValidateBeforeCall(String txId, Integer eventOffset, Integer eventLimit, Boolean unanchored, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'txId' is set
        if (txId == null) {
            throw new ApiException("Missing the required parameter 'txId' when calling getTransactionById(Async)");
        }
        

        okhttp3.Call localVarCall = getTransactionByIdCall(txId, eventOffset, eventLimit, unanchored, _callback);
        return localVarCall;

    }

    /**
     * Get transaction
     * Retrieves transaction details for a given transaction ID  &#x60;import type { Transaction } from &#39;@stacks/stacks-blockchain-api-types&#39;;&#x60; 
     * @param txId Hash of transaction (required)
     * @param eventOffset The number of events to skip (optional, default to 0)
     * @param eventLimit The numbers of events to return (optional, default to 96)
     * @param unanchored Include transaction data from unanchored (i.e. unconfirmed) microblocks (optional, default to false)
     * @return AnyOfobjectobjectobjectobjectobject
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Transaction </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot find transaction for given ID </td><td>  -  </td></tr>
     </table>
     */
    public AnyOfobjectobjectobjectobjectobject getTransactionById(String txId, Integer eventOffset, Integer eventLimit, Boolean unanchored) throws ApiException {
        ApiResponse<AnyOfobjectobjectobjectobjectobject> localVarResp = getTransactionByIdWithHttpInfo(txId, eventOffset, eventLimit, unanchored);
        return localVarResp.getData();
    }

    /**
     * Get transaction
     * Retrieves transaction details for a given transaction ID  &#x60;import type { Transaction } from &#39;@stacks/stacks-blockchain-api-types&#39;;&#x60; 
     * @param txId Hash of transaction (required)
     * @param eventOffset The number of events to skip (optional, default to 0)
     * @param eventLimit The numbers of events to return (optional, default to 96)
     * @param unanchored Include transaction data from unanchored (i.e. unconfirmed) microblocks (optional, default to false)
     * @return ApiResponse&lt;AnyOfobjectobjectobjectobjectobject&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Transaction </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot find transaction for given ID </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AnyOfobjectobjectobjectobjectobject> getTransactionByIdWithHttpInfo(String txId, Integer eventOffset, Integer eventLimit, Boolean unanchored) throws ApiException {
        okhttp3.Call localVarCall = getTransactionByIdValidateBeforeCall(txId, eventOffset, eventLimit, unanchored, null);
        Type localVarReturnType = new TypeToken<AnyOfobjectobjectobjectobjectobject>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get transaction (asynchronously)
     * Retrieves transaction details for a given transaction ID  &#x60;import type { Transaction } from &#39;@stacks/stacks-blockchain-api-types&#39;;&#x60; 
     * @param txId Hash of transaction (required)
     * @param eventOffset The number of events to skip (optional, default to 0)
     * @param eventLimit The numbers of events to return (optional, default to 96)
     * @param unanchored Include transaction data from unanchored (i.e. unconfirmed) microblocks (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Transaction </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot find transaction for given ID </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getTransactionByIdAsync(String txId, Integer eventOffset, Integer eventLimit, Boolean unanchored, final ApiCallback<AnyOfobjectobjectobjectobjectobject> _callback) throws ApiException {

        okhttp3.Call localVarCall = getTransactionByIdValidateBeforeCall(txId, eventOffset, eventLimit, unanchored, _callback);
        Type localVarReturnType = new TypeToken<AnyOfobjectobjectobjectobjectobject>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getTransactionList
     * @param limit max number of transactions to fetch (optional, default to 96)
     * @param offset index of first transaction to fetch (optional)
     * @param type Filter by transaction type (optional)
     * @param unanchored Include transaction data from unanchored (i.e. unconfirmed) microblocks (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of transactions </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getTransactionListCall(Integer limit, Integer offset, List<String> type, Boolean unanchored, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/extended/v1/tx";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (type != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "type", type));
        }

        if (unanchored != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("unanchored", unanchored));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getTransactionListValidateBeforeCall(Integer limit, Integer offset, List<String> type, Boolean unanchored, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = getTransactionListCall(limit, offset, type, unanchored, _callback);
        return localVarCall;

    }

    /**
     * Get recent transactions
     * Retrieves all recently mined transactions  If using TypeScript, import typings for this response from our types package:  &#x60;import type { TransactionResults } from &#39;@stacks/stacks-blockchain-api-types&#39;;&#x60; 
     * @param limit max number of transactions to fetch (optional, default to 96)
     * @param offset index of first transaction to fetch (optional)
     * @param type Filter by transaction type (optional)
     * @param unanchored Include transaction data from unanchored (i.e. unconfirmed) microblocks (optional, default to false)
     * @return TransactionResults
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of transactions </td><td>  -  </td></tr>
     </table>
     */
    public TransactionResults getTransactionList(Integer limit, Integer offset, List<String> type, Boolean unanchored) throws ApiException {
        ApiResponse<TransactionResults> localVarResp = getTransactionListWithHttpInfo(limit, offset, type, unanchored);
        return localVarResp.getData();
    }

    /**
     * Get recent transactions
     * Retrieves all recently mined transactions  If using TypeScript, import typings for this response from our types package:  &#x60;import type { TransactionResults } from &#39;@stacks/stacks-blockchain-api-types&#39;;&#x60; 
     * @param limit max number of transactions to fetch (optional, default to 96)
     * @param offset index of first transaction to fetch (optional)
     * @param type Filter by transaction type (optional)
     * @param unanchored Include transaction data from unanchored (i.e. unconfirmed) microblocks (optional, default to false)
     * @return ApiResponse&lt;TransactionResults&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of transactions </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TransactionResults> getTransactionListWithHttpInfo(Integer limit, Integer offset, List<String> type, Boolean unanchored) throws ApiException {
        okhttp3.Call localVarCall = getTransactionListValidateBeforeCall(limit, offset, type, unanchored, null);
        Type localVarReturnType = new TypeToken<TransactionResults>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get recent transactions (asynchronously)
     * Retrieves all recently mined transactions  If using TypeScript, import typings for this response from our types package:  &#x60;import type { TransactionResults } from &#39;@stacks/stacks-blockchain-api-types&#39;;&#x60; 
     * @param limit max number of transactions to fetch (optional, default to 96)
     * @param offset index of first transaction to fetch (optional)
     * @param type Filter by transaction type (optional)
     * @param unanchored Include transaction data from unanchored (i.e. unconfirmed) microblocks (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of transactions </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getTransactionListAsync(Integer limit, Integer offset, List<String> type, Boolean unanchored, final ApiCallback<TransactionResults> _callback) throws ApiException {

        okhttp3.Call localVarCall = getTransactionListValidateBeforeCall(limit, offset, type, unanchored, _callback);
        Type localVarReturnType = new TypeToken<TransactionResults>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getTransactionsByBlockHash
     * @param blockHash Hash of block (required)
     * @param limit max number of transactions to fetch (optional)
     * @param offset index of first transaction to fetch (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of Transactions </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getTransactionsByBlockHashCall(String blockHash, Integer limit, Integer offset, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/extended/v1/tx/block/{block_hash}"
            .replaceAll("\\{" + "block_hash" + "\\}", localVarApiClient.escapeString(blockHash.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getTransactionsByBlockHashValidateBeforeCall(String blockHash, Integer limit, Integer offset, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'blockHash' is set
        if (blockHash == null) {
            throw new ApiException("Missing the required parameter 'blockHash' when calling getTransactionsByBlockHash(Async)");
        }
        

        okhttp3.Call localVarCall = getTransactionsByBlockHashCall(blockHash, limit, offset, _callback);
        return localVarCall;

    }

    /**
     * Transactions by block hash
     * Retrieves a list of all transactions within a block for a given block hash.
     * @param blockHash Hash of block (required)
     * @param limit max number of transactions to fetch (optional)
     * @param offset index of first transaction to fetch (optional)
     * @return Object
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of Transactions </td><td>  -  </td></tr>
     </table>
     */
    public Object getTransactionsByBlockHash(String blockHash, Integer limit, Integer offset) throws ApiException {
        ApiResponse<Object> localVarResp = getTransactionsByBlockHashWithHttpInfo(blockHash, limit, offset);
        return localVarResp.getData();
    }

    /**
     * Transactions by block hash
     * Retrieves a list of all transactions within a block for a given block hash.
     * @param blockHash Hash of block (required)
     * @param limit max number of transactions to fetch (optional)
     * @param offset index of first transaction to fetch (optional)
     * @return ApiResponse&lt;Object&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of Transactions </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Object> getTransactionsByBlockHashWithHttpInfo(String blockHash, Integer limit, Integer offset) throws ApiException {
        okhttp3.Call localVarCall = getTransactionsByBlockHashValidateBeforeCall(blockHash, limit, offset, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Transactions by block hash (asynchronously)
     * Retrieves a list of all transactions within a block for a given block hash.
     * @param blockHash Hash of block (required)
     * @param limit max number of transactions to fetch (optional)
     * @param offset index of first transaction to fetch (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of Transactions </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getTransactionsByBlockHashAsync(String blockHash, Integer limit, Integer offset, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = getTransactionsByBlockHashValidateBeforeCall(blockHash, limit, offset, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getTransactionsByBlockHeight
     * @param height Height of block (required)
     * @param limit max number of transactions to fetch (optional)
     * @param offset index of first transaction to fetch (optional)
     * @param unanchored Include transaction data from unanchored (i.e. unconfirmed) microblocks (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of Transactions </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getTransactionsByBlockHeightCall(Integer height, Integer limit, Integer offset, Boolean unanchored, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/extended/v1/tx/block_height/{height}"
            .replaceAll("\\{" + "height" + "\\}", localVarApiClient.escapeString(height.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (unanchored != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("unanchored", unanchored));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getTransactionsByBlockHeightValidateBeforeCall(Integer height, Integer limit, Integer offset, Boolean unanchored, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'height' is set
        if (height == null) {
            throw new ApiException("Missing the required parameter 'height' when calling getTransactionsByBlockHeight(Async)");
        }
        

        okhttp3.Call localVarCall = getTransactionsByBlockHeightCall(height, limit, offset, unanchored, _callback);
        return localVarCall;

    }

    /**
     * Transactions by block height
     * Retrieves all transactions within a block at a given height
     * @param height Height of block (required)
     * @param limit max number of transactions to fetch (optional)
     * @param offset index of first transaction to fetch (optional)
     * @param unanchored Include transaction data from unanchored (i.e. unconfirmed) microblocks (optional, default to false)
     * @return Object
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of Transactions </td><td>  -  </td></tr>
     </table>
     */
    public Object getTransactionsByBlockHeight(Integer height, Integer limit, Integer offset, Boolean unanchored) throws ApiException {
        ApiResponse<Object> localVarResp = getTransactionsByBlockHeightWithHttpInfo(height, limit, offset, unanchored);
        return localVarResp.getData();
    }

    /**
     * Transactions by block height
     * Retrieves all transactions within a block at a given height
     * @param height Height of block (required)
     * @param limit max number of transactions to fetch (optional)
     * @param offset index of first transaction to fetch (optional)
     * @param unanchored Include transaction data from unanchored (i.e. unconfirmed) microblocks (optional, default to false)
     * @return ApiResponse&lt;Object&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of Transactions </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Object> getTransactionsByBlockHeightWithHttpInfo(Integer height, Integer limit, Integer offset, Boolean unanchored) throws ApiException {
        okhttp3.Call localVarCall = getTransactionsByBlockHeightValidateBeforeCall(height, limit, offset, unanchored, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Transactions by block height (asynchronously)
     * Retrieves all transactions within a block at a given height
     * @param height Height of block (required)
     * @param limit max number of transactions to fetch (optional)
     * @param offset index of first transaction to fetch (optional)
     * @param unanchored Include transaction data from unanchored (i.e. unconfirmed) microblocks (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List of Transactions </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getTransactionsByBlockHeightAsync(Integer height, Integer limit, Integer offset, Boolean unanchored, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = getTransactionsByBlockHeightValidateBeforeCall(height, limit, offset, unanchored, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getTxListDetails
     * @param txId Array of transaction ids (required)
     * @param eventOffset The number of events to skip (optional, default to 0)
     * @param eventLimit The numbers of events to return (optional, default to 96)
     * @param unanchored Include transaction data from unanchored (i.e. unconfirmed) microblocks (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns list of transactions with their details for corresponding requested tx_ids. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Could not find any transaction by ID </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getTxListDetailsCall(List<String> txId, Integer eventOffset, Integer eventLimit, Boolean unanchored, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/extended/v1/tx/multiple";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (txId != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "tx_id", txId));
        }

        if (eventOffset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("event_offset", eventOffset));
        }

        if (eventLimit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("event_limit", eventLimit));
        }

        if (unanchored != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("unanchored", unanchored));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getTxListDetailsValidateBeforeCall(List<String> txId, Integer eventOffset, Integer eventLimit, Boolean unanchored, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'txId' is set
        if (txId == null) {
            throw new ApiException("Missing the required parameter 'txId' when calling getTxListDetails(Async)");
        }
        

        okhttp3.Call localVarCall = getTxListDetailsCall(txId, eventOffset, eventLimit, unanchored, _callback);
        return localVarCall;

    }

    /**
     * Get list of details for transactions
     * Retrieves a list of transactions for a given list of transaction IDs  If using TypeScript, import typings for this response from our types package:  &#x60;import type { Transaction } from &#39;@stacks/stacks-blockchain-api-types&#39;;&#x60; 
     * @param txId Array of transaction ids (required)
     * @param eventOffset The number of events to skip (optional, default to 0)
     * @param eventLimit The numbers of events to return (optional, default to 96)
     * @param unanchored Include transaction data from unanchored (i.e. unconfirmed) microblocks (optional, default to false)
     * @return Map&lt;String, AnyOfobjectobject&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns list of transactions with their details for corresponding requested tx_ids. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Could not find any transaction by ID </td><td>  -  </td></tr>
     </table>
     */
    public Map<String, AnyOfobjectobject> getTxListDetails(List<String> txId, Integer eventOffset, Integer eventLimit, Boolean unanchored) throws ApiException {
        ApiResponse<Map<String, AnyOfobjectobject>> localVarResp = getTxListDetailsWithHttpInfo(txId, eventOffset, eventLimit, unanchored);
        return localVarResp.getData();
    }

    /**
     * Get list of details for transactions
     * Retrieves a list of transactions for a given list of transaction IDs  If using TypeScript, import typings for this response from our types package:  &#x60;import type { Transaction } from &#39;@stacks/stacks-blockchain-api-types&#39;;&#x60; 
     * @param txId Array of transaction ids (required)
     * @param eventOffset The number of events to skip (optional, default to 0)
     * @param eventLimit The numbers of events to return (optional, default to 96)
     * @param unanchored Include transaction data from unanchored (i.e. unconfirmed) microblocks (optional, default to false)
     * @return ApiResponse&lt;Map&lt;String, AnyOfobjectobject&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns list of transactions with their details for corresponding requested tx_ids. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Could not find any transaction by ID </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Map<String, AnyOfobjectobject>> getTxListDetailsWithHttpInfo(List<String> txId, Integer eventOffset, Integer eventLimit, Boolean unanchored) throws ApiException {
        okhttp3.Call localVarCall = getTxListDetailsValidateBeforeCall(txId, eventOffset, eventLimit, unanchored, null);
        Type localVarReturnType = new TypeToken<Map<String, AnyOfobjectobject>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get list of details for transactions (asynchronously)
     * Retrieves a list of transactions for a given list of transaction IDs  If using TypeScript, import typings for this response from our types package:  &#x60;import type { Transaction } from &#39;@stacks/stacks-blockchain-api-types&#39;;&#x60; 
     * @param txId Array of transaction ids (required)
     * @param eventOffset The number of events to skip (optional, default to 0)
     * @param eventLimit The numbers of events to return (optional, default to 96)
     * @param unanchored Include transaction data from unanchored (i.e. unconfirmed) microblocks (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns list of transactions with their details for corresponding requested tx_ids. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Could not find any transaction by ID </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getTxListDetailsAsync(List<String> txId, Integer eventOffset, Integer eventLimit, Boolean unanchored, final ApiCallback<Map<String, AnyOfobjectobject>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getTxListDetailsValidateBeforeCall(txId, eventOffset, eventLimit, unanchored, _callback);
        Type localVarReturnType = new TypeToken<Map<String, AnyOfobjectobject>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postCoreNodeTransactions
     * @param body  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Transaction id of successful post of a raw tx to the node&#39;s mempool </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Rejections result in a 400 error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postCoreNodeTransactionsCall(File body, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/v2/transactions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/plain", "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/octet-stream"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postCoreNodeTransactionsValidateBeforeCall(File body, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = postCoreNodeTransactionsCall(body, _callback);
        return localVarCall;

    }

    /**
     * Broadcast raw transaction
     * Broadcasts raw transactions on the network. You can use the [@stacks/transactions](https://github.com/blockstack/stacks.js) project to generate a raw transaction payload.
     * @param body  (optional)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Transaction id of successful post of a raw tx to the node&#39;s mempool </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Rejections result in a 400 error </td><td>  -  </td></tr>
     </table>
     */
    public String postCoreNodeTransactions(File body) throws ApiException {
        ApiResponse<String> localVarResp = postCoreNodeTransactionsWithHttpInfo(body);
        return localVarResp.getData();
    }

    /**
     * Broadcast raw transaction
     * Broadcasts raw transactions on the network. You can use the [@stacks/transactions](https://github.com/blockstack/stacks.js) project to generate a raw transaction payload.
     * @param body  (optional)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Transaction id of successful post of a raw tx to the node&#39;s mempool </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Rejections result in a 400 error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<String> postCoreNodeTransactionsWithHttpInfo(File body) throws ApiException {
        okhttp3.Call localVarCall = postCoreNodeTransactionsValidateBeforeCall(body, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Broadcast raw transaction (asynchronously)
     * Broadcasts raw transactions on the network. You can use the [@stacks/transactions](https://github.com/blockstack/stacks.js) project to generate a raw transaction payload.
     * @param body  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Transaction id of successful post of a raw tx to the node&#39;s mempool </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Rejections result in a 400 error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postCoreNodeTransactionsAsync(File body, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = postCoreNodeTransactionsValidateBeforeCall(body, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
