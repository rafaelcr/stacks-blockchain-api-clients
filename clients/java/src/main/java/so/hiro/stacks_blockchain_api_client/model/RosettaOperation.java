/*
 * Stacks Blockchain API
 * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a> 
 *
 * The version of the OpenAPI document: v3.0.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package so.hiro.stacks_blockchain_api_client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import so.hiro.stacks_blockchain_api_client.model.RosettaCoinChange;
import so.hiro.stacks_blockchain_api_client.model.RosettaOperationIdentifier;
import so.hiro.stacks_blockchain_api_client.model.RosettaRelatedOperation;

/**
 * Operations contain all balance-changing information within a transaction. They are always one-sided (only affect 1 AccountIdentifier) and can succeed or fail independently from a Transaction.
 */
@ApiModel(description = "Operations contain all balance-changing information within a transaction. They are always one-sided (only affect 1 AccountIdentifier) and can succeed or fail independently from a Transaction.")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2022-05-14T17:31:43.521-05:00[America/Monterrey]")
public class RosettaOperation {
  public static final String SERIALIZED_NAME_OPERATION_IDENTIFIER = "operation_identifier";
  @SerializedName(SERIALIZED_NAME_OPERATION_IDENTIFIER)
  private RosettaOperationIdentifier operationIdentifier;

  public static final String SERIALIZED_NAME_RELATED_OPERATIONS = "related_operations";
  @SerializedName(SERIALIZED_NAME_RELATED_OPERATIONS)
  private List<RosettaRelatedOperation> relatedOperations = null;

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private String type;

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private String status;

  public static final String SERIALIZED_NAME_ACCOUNT = "account";
  @SerializedName(SERIALIZED_NAME_ACCOUNT)
  private Object account = null;

  public static final String SERIALIZED_NAME_AMOUNT = "amount";
  @SerializedName(SERIALIZED_NAME_AMOUNT)
  private Object amount = null;

  public static final String SERIALIZED_NAME_COIN_CHANGE = "coin_change";
  @SerializedName(SERIALIZED_NAME_COIN_CHANGE)
  private RosettaCoinChange coinChange;

  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  private Object metadata;

  public RosettaOperation() { 
  }

  public RosettaOperation operationIdentifier(RosettaOperationIdentifier operationIdentifier) {
    
    this.operationIdentifier = operationIdentifier;
    return this;
  }

   /**
   * Get operationIdentifier
   * @return operationIdentifier
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public RosettaOperationIdentifier getOperationIdentifier() {
    return operationIdentifier;
  }


  public void setOperationIdentifier(RosettaOperationIdentifier operationIdentifier) {
    this.operationIdentifier = operationIdentifier;
  }


  public RosettaOperation relatedOperations(List<RosettaRelatedOperation> relatedOperations) {
    
    this.relatedOperations = relatedOperations;
    return this;
  }

  public RosettaOperation addRelatedOperationsItem(RosettaRelatedOperation relatedOperationsItem) {
    if (this.relatedOperations == null) {
      this.relatedOperations = new ArrayList<RosettaRelatedOperation>();
    }
    this.relatedOperations.add(relatedOperationsItem);
    return this;
  }

   /**
   * Restrict referenced related_operations to identifier indexes &lt; the current operation_identifier.index. This ensures there exists a clear DAG-structure of relations. Since operations are one-sided, one could imagine relating operations in a single transfer or linking operations in a call tree.
   * @return relatedOperations
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Restrict referenced related_operations to identifier indexes < the current operation_identifier.index. This ensures there exists a clear DAG-structure of relations. Since operations are one-sided, one could imagine relating operations in a single transfer or linking operations in a call tree.")

  public List<RosettaRelatedOperation> getRelatedOperations() {
    return relatedOperations;
  }


  public void setRelatedOperations(List<RosettaRelatedOperation> relatedOperations) {
    this.relatedOperations = relatedOperations;
  }


  public RosettaOperation type(String type) {
    
    this.type = type;
    return this;
  }

   /**
   * The network-specific type of the operation. Ensure that any type that can be returned here is also specified in the NetworkStatus. This can be very useful to downstream consumers that parse all block data.
   * @return type
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "The network-specific type of the operation. Ensure that any type that can be returned here is also specified in the NetworkStatus. This can be very useful to downstream consumers that parse all block data.")

  public String getType() {
    return type;
  }


  public void setType(String type) {
    this.type = type;
  }


  public RosettaOperation status(String status) {
    
    this.status = status;
    return this;
  }

   /**
   * The network-specific status of the operation. Status is not defined on the transaction object because blockchains with smart contracts may have transactions that partially apply. Blockchains with atomic transactions (all operations succeed or all operations fail) will have the same status for each operation.
   * @return status
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The network-specific status of the operation. Status is not defined on the transaction object because blockchains with smart contracts may have transactions that partially apply. Blockchains with atomic transactions (all operations succeed or all operations fail) will have the same status for each operation.")

  public String getStatus() {
    return status;
  }


  public void setStatus(String status) {
    this.status = status;
  }


  public RosettaOperation account(Object account) {
    
    this.account = account;
    return this;
  }

   /**
   * Get account
   * @return account
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public Object getAccount() {
    return account;
  }


  public void setAccount(Object account) {
    this.account = account;
  }


  public RosettaOperation amount(Object amount) {
    
    this.amount = amount;
    return this;
  }

   /**
   * Get amount
   * @return amount
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public Object getAmount() {
    return amount;
  }


  public void setAmount(Object amount) {
    this.amount = amount;
  }


  public RosettaOperation coinChange(RosettaCoinChange coinChange) {
    
    this.coinChange = coinChange;
    return this;
  }

   /**
   * Get coinChange
   * @return coinChange
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public RosettaCoinChange getCoinChange() {
    return coinChange;
  }


  public void setCoinChange(RosettaCoinChange coinChange) {
    this.coinChange = coinChange;
  }


  public RosettaOperation metadata(Object metadata) {
    
    this.metadata = metadata;
    return this;
  }

   /**
   * Operations Meta Data
   * @return metadata
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Operations Meta Data")

  public Object getMetadata() {
    return metadata;
  }


  public void setMetadata(Object metadata) {
    this.metadata = metadata;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RosettaOperation rosettaOperation = (RosettaOperation) o;
    return Objects.equals(this.operationIdentifier, rosettaOperation.operationIdentifier) &&
        Objects.equals(this.relatedOperations, rosettaOperation.relatedOperations) &&
        Objects.equals(this.type, rosettaOperation.type) &&
        Objects.equals(this.status, rosettaOperation.status) &&
        Objects.equals(this.account, rosettaOperation.account) &&
        Objects.equals(this.amount, rosettaOperation.amount) &&
        Objects.equals(this.coinChange, rosettaOperation.coinChange) &&
        Objects.equals(this.metadata, rosettaOperation.metadata);
  }

  @Override
  public int hashCode() {
    return Objects.hash(operationIdentifier, relatedOperations, type, status, account, amount, coinChange, metadata);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RosettaOperation {\n");
    sb.append("    operationIdentifier: ").append(toIndentedString(operationIdentifier)).append("\n");
    sb.append("    relatedOperations: ").append(toIndentedString(relatedOperations)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    account: ").append(toIndentedString(account)).append("\n");
    sb.append("    amount: ").append(toIndentedString(amount)).append("\n");
    sb.append("    coinChange: ").append(toIndentedString(coinChange)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

