/*
 * Stacks Blockchain API
 * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a> 
 *
 * The version of the OpenAPI document: v3.0.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package so.hiro.stacks_blockchain_api_client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;

/**
 * Signature contains the payload that was signed, the public keys of the keypairs used to produce the signature, the signature (encoded in hex), and the SignatureType. PublicKey is often times not known during construction of the signing payloads but may be needed to combine signatures properly.
 */
@ApiModel(description = "Signature contains the payload that was signed, the public keys of the keypairs used to produce the signature, the signature (encoded in hex), and the SignatureType. PublicKey is often times not known during construction of the signing payloads but may be needed to combine signatures properly.")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2022-05-14T17:31:43.521-05:00[America/Monterrey]")
public class RosettaSignature {
  public static final String SERIALIZED_NAME_SIGNING_PAYLOAD = "signing_payload";
  @SerializedName(SERIALIZED_NAME_SIGNING_PAYLOAD)
  private Object signingPayload = null;

  public static final String SERIALIZED_NAME_PUBLIC_KEY = "public_key";
  @SerializedName(SERIALIZED_NAME_PUBLIC_KEY)
  private Object publicKey = null;

  /**
   * SignatureType is the type of a cryptographic signature.
   */
  @JsonAdapter(SignatureTypeEnum.Adapter.class)
  public enum SignatureTypeEnum {
    ECDSA("ecdsa"),
    
    ECDSA_RECOVERY("ecdsa_recovery"),
    
    ED25519("ed25519"),
    
    SCHNORR_1("schnorr_1"),
    
    SCHNORR_POSEIDON("schnorr_poseidon");

    private String value;

    SignatureTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SignatureTypeEnum fromValue(String value) {
      for (SignatureTypeEnum b : SignatureTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SignatureTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SignatureTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SignatureTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SignatureTypeEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_SIGNATURE_TYPE = "signature_type";
  @SerializedName(SERIALIZED_NAME_SIGNATURE_TYPE)
  private SignatureTypeEnum signatureType;

  public static final String SERIALIZED_NAME_HEX_BYTES = "hex_bytes";
  @SerializedName(SERIALIZED_NAME_HEX_BYTES)
  private String hexBytes;

  public RosettaSignature() { 
  }

  public RosettaSignature signingPayload(Object signingPayload) {
    
    this.signingPayload = signingPayload;
    return this;
  }

   /**
   * Get signingPayload
   * @return signingPayload
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public Object getSigningPayload() {
    return signingPayload;
  }


  public void setSigningPayload(Object signingPayload) {
    this.signingPayload = signingPayload;
  }


  public RosettaSignature publicKey(Object publicKey) {
    
    this.publicKey = publicKey;
    return this;
  }

   /**
   * Get publicKey
   * @return publicKey
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public Object getPublicKey() {
    return publicKey;
  }


  public void setPublicKey(Object publicKey) {
    this.publicKey = publicKey;
  }


  public RosettaSignature signatureType(SignatureTypeEnum signatureType) {
    
    this.signatureType = signatureType;
    return this;
  }

   /**
   * SignatureType is the type of a cryptographic signature.
   * @return signatureType
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "SignatureType is the type of a cryptographic signature.")

  public SignatureTypeEnum getSignatureType() {
    return signatureType;
  }


  public void setSignatureType(SignatureTypeEnum signatureType) {
    this.signatureType = signatureType;
  }


  public RosettaSignature hexBytes(String hexBytes) {
    
    this.hexBytes = hexBytes;
    return this;
  }

   /**
   * Get hexBytes
   * @return hexBytes
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public String getHexBytes() {
    return hexBytes;
  }


  public void setHexBytes(String hexBytes) {
    this.hexBytes = hexBytes;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RosettaSignature rosettaSignature = (RosettaSignature) o;
    return Objects.equals(this.signingPayload, rosettaSignature.signingPayload) &&
        Objects.equals(this.publicKey, rosettaSignature.publicKey) &&
        Objects.equals(this.signatureType, rosettaSignature.signatureType) &&
        Objects.equals(this.hexBytes, rosettaSignature.hexBytes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(signingPayload, publicKey, signatureType, hexBytes);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RosettaSignature {\n");
    sb.append("    signingPayload: ").append(toIndentedString(signingPayload)).append("\n");
    sb.append("    publicKey: ").append(toIndentedString(publicKey)).append("\n");
    sb.append("    signatureType: ").append(toIndentedString(signatureType)).append("\n");
    sb.append("    hexBytes: ").append(toIndentedString(hexBytes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

