//
// Microblock.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** A microblock */
public struct Microblock: Codable, JSONEncodable, Hashable {

    /** Set to `true` if the microblock corresponds to the canonical chain tip. */
    public var canonical: Bool
    /** Set to `true` if the microblock was not orphaned in a following anchor block. Defaults to `true` if the following anchor block has not yet been created. */
    public var microblockCanonical: Bool
    /** The SHA512/256 hash of this microblock. */
    public var microblockHash: String
    /** A hint to describe how to order a set of microblocks. Starts at 0. */
    public var microblockSequence: Int
    /** The SHA512/256 hash of the previous signed microblock in this stream. */
    public var microblockParentHash: String
    /** The anchor block height that confirmed this microblock. */
    public var blockHeight: Int
    /** The height of the anchor block that preceded this microblock. */
    public var parentBlockHeight: Int
    /** The hash of the anchor block that preceded this microblock. */
    public var parentBlockHash: String
    /** The hash of the Bitcoin block that preceded this microblock. */
    public var parentBurnBlockHash: String
    /** The block timestamp of the Bitcoin block that preceded this microblock. */
    public var parentBurnBlockTime: Int
    /** The ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) formatted block time of the bitcoin block that preceded this microblock. */
    public var parentBurnBlockTimeIso: String
    /** The height of the Bitcoin block that preceded this microblock. */
    public var parentBurnBlockHeight: Int
    /** The hash of the anchor block that confirmed this microblock. This wil be empty for unanchored microblocks */
    public var blockHash: String?
    /** List of transactions included in the microblock */
    public var txs: [String]

    public init(canonical: Bool, microblockCanonical: Bool, microblockHash: String, microblockSequence: Int, microblockParentHash: String, blockHeight: Int, parentBlockHeight: Int, parentBlockHash: String, parentBurnBlockHash: String, parentBurnBlockTime: Int, parentBurnBlockTimeIso: String, parentBurnBlockHeight: Int, blockHash: String?, txs: [String]) {
        self.canonical = canonical
        self.microblockCanonical = microblockCanonical
        self.microblockHash = microblockHash
        self.microblockSequence = microblockSequence
        self.microblockParentHash = microblockParentHash
        self.blockHeight = blockHeight
        self.parentBlockHeight = parentBlockHeight
        self.parentBlockHash = parentBlockHash
        self.parentBurnBlockHash = parentBurnBlockHash
        self.parentBurnBlockTime = parentBurnBlockTime
        self.parentBurnBlockTimeIso = parentBurnBlockTimeIso
        self.parentBurnBlockHeight = parentBurnBlockHeight
        self.blockHash = blockHash
        self.txs = txs
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case canonical
        case microblockCanonical = "microblock_canonical"
        case microblockHash = "microblock_hash"
        case microblockSequence = "microblock_sequence"
        case microblockParentHash = "microblock_parent_hash"
        case blockHeight = "block_height"
        case parentBlockHeight = "parent_block_height"
        case parentBlockHash = "parent_block_hash"
        case parentBurnBlockHash = "parent_burn_block_hash"
        case parentBurnBlockTime = "parent_burn_block_time"
        case parentBurnBlockTimeIso = "parent_burn_block_time_iso"
        case parentBurnBlockHeight = "parent_burn_block_height"
        case blockHash = "block_hash"
        case txs
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(canonical, forKey: .canonical)
        try container.encode(microblockCanonical, forKey: .microblockCanonical)
        try container.encode(microblockHash, forKey: .microblockHash)
        try container.encode(microblockSequence, forKey: .microblockSequence)
        try container.encode(microblockParentHash, forKey: .microblockParentHash)
        try container.encode(blockHeight, forKey: .blockHeight)
        try container.encode(parentBlockHeight, forKey: .parentBlockHeight)
        try container.encode(parentBlockHash, forKey: .parentBlockHash)
        try container.encode(parentBurnBlockHash, forKey: .parentBurnBlockHash)
        try container.encode(parentBurnBlockTime, forKey: .parentBurnBlockTime)
        try container.encode(parentBurnBlockTimeIso, forKey: .parentBurnBlockTimeIso)
        try container.encode(parentBurnBlockHeight, forKey: .parentBurnBlockHeight)
        try container.encode(blockHash, forKey: .blockHash)
        try container.encode(txs, forKey: .txs)
    }
}

