//
// RosettaAccountBalanceResponse.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** An AccountBalanceResponse is returned on the /account/balance endpoint. If an account has a balance for each AccountIdentifier describing it (ex: an ERC-20 token balance on a few smart contracts), an account balance request must be made with each AccountIdentifier. */
public struct RosettaAccountBalanceResponse: Codable, JSONEncodable, Hashable {

    public var blockIdentifier: AnyCodable
    /** A single account balance may have multiple currencies */
    public var balances: [RosettaAmount]
    /** If a blockchain is UTXO-based, all unspent Coins owned by an account_identifier should be returned alongside the balance. It is highly recommended to populate this field so that users of the Rosetta API implementation don't need to maintain their own indexer to track their UTXOs. */
    public var coins: [RosettaCoin]?
    public var metadata: RosettaAccountBalanceResponseMetadata?

    public init(blockIdentifier: AnyCodable, balances: [RosettaAmount], coins: [RosettaCoin]? = nil, metadata: RosettaAccountBalanceResponseMetadata? = nil) {
        self.blockIdentifier = blockIdentifier
        self.balances = balances
        self.coins = coins
        self.metadata = metadata
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case blockIdentifier = "block_identifier"
        case balances
        case coins
        case metadata
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(blockIdentifier, forKey: .blockIdentifier)
        try container.encode(balances, forKey: .balances)
        try container.encodeIfPresent(coins, forKey: .coins)
        try container.encodeIfPresent(metadata, forKey: .metadata)
    }
}

