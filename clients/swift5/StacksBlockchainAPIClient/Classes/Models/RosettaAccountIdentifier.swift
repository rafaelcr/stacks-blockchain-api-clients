//
// RosettaAccountIdentifier.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** The account_identifier uniquely identifies an account within a network. All fields in the account_identifier are utilized to determine this uniqueness (including the metadata field, if populated). */
public struct RosettaAccountIdentifier: Codable, JSONEncodable, Hashable {

    /** The address may be a cryptographic public key (or some encoding of it) or a provided username. */
    public var address: String
    public var subAccount: AnyCodable?
    /** Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata. */
    public var metadata: AnyCodable?

    public init(address: String, subAccount: AnyCodable? = nil, metadata: AnyCodable? = nil) {
        self.address = address
        self.subAccount = subAccount
        self.metadata = metadata
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case address
        case subAccount = "sub_account"
        case metadata
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(address, forKey: .address)
        try container.encodeIfPresent(subAccount, forKey: .subAccount)
        try container.encodeIfPresent(metadata, forKey: .metadata)
    }
}

