//
// RosettaBlock.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Blocks contain an array of Transactions that occurred at a particular BlockIdentifier. A hard requirement for blocks returned by Rosetta implementations is that they MUST be inalterable: once a client has requested and received a block identified by a specific BlockIndentifier, all future calls for that same BlockIdentifier must return the same block contents. */
public struct RosettaBlock: Codable, JSONEncodable, Hashable {

    public var blockIdentifier: AnyCodable
    public var parentBlockIdentifier: RosettaParentBlockIdentifier
    /** The timestamp of the block in milliseconds since the Unix Epoch. The timestamp is stored in milliseconds because some blockchains produce blocks more often than once a second. */
    public var timestamp: Int
    /** All the transactions in the block */
    public var transactions: [AnyCodable]
    public var metadata: RosettaBlockMetadata?

    public init(blockIdentifier: AnyCodable, parentBlockIdentifier: RosettaParentBlockIdentifier, timestamp: Int, transactions: [AnyCodable], metadata: RosettaBlockMetadata? = nil) {
        self.blockIdentifier = blockIdentifier
        self.parentBlockIdentifier = parentBlockIdentifier
        self.timestamp = timestamp
        self.transactions = transactions
        self.metadata = metadata
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case blockIdentifier = "block_identifier"
        case parentBlockIdentifier = "parent_block_identifier"
        case timestamp
        case transactions
        case metadata
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(blockIdentifier, forKey: .blockIdentifier)
        try container.encode(parentBlockIdentifier, forKey: .parentBlockIdentifier)
        try container.encode(timestamp, forKey: .timestamp)
        try container.encode(transactions, forKey: .transactions)
        try container.encodeIfPresent(metadata, forKey: .metadata)
    }
}

